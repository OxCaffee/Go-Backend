# Golang内存管理

<!-- vscode-markdown-toc -->
* 1. [前言](#)
* 2. [Go的虚拟内存演变](#Go)
	* 2.1. [Go1.10版本之前的堆区内存——线性内存](#Go1.10)
		* 2.1.1. [线性堆内存的弊端](#-1)
	* 2.2. [Go1.11版本开始的堆区内存——稀疏内存](#Go1.11)
* 3. [Go语言的内存管理组件](#Go-1)

<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->

##  1. <a name=''></a>前言

在计算机系统中，主存`Memory`被组织成一个由连续字节组成的数组，每一个字节都有唯一的物理地址(`Physic Address`)。现代处理器使用的是一种虚拟寻址的方式(`Virtual Address`)的寻址形式，最少的寻址单位是字。虚拟地址向物理地址的转换是`MMU`查询页表进行转换完成的，页表存储在物理存储器中，一般来说，物理页的大小和虚拟页的大小相等。

##  2. <a name='Go'></a>Go的虚拟内存演变

###  2.1. <a name='Go1.10'></a>Go1.10版本之前的堆区内存——线性内存

Go在1.10版本之前启动的时候会初始化整个虚拟内存，并且**堆区的内存空间都是连续的**，如下所示的三个区域`spans`, `bitmap`, `arena`分别预留了`512MB`, `16GB`, `512GB`的内存空间，**这些内存并不是真正的物理内存，而是虚拟内存** 。

<div align=center><img src="/assets/gmm1.png"/></div>



- `spans` 区域存储了指向内存管理单元 `runtime.mspan`的指针，每个内存单元会管理几页的内存空间，每页大小为 8KB，**一些页的组合被称为`mspan`**
- `bitmap` 用于标识 `arena` 区域中的那些地址保存了对象，并且用4bit来表示对象是否包含指针，GC标记信息。`bitmap`中的一个字节大小对应了`arena`区域4个指针的大小的内存，所以`bitmap`区域的大小为`512GB/(4*8B)=16GB`
- `arena` 区域是真正的堆区，运行时会将 8KB 看做一页，这些内存页中存储了所有在堆上初始化的对象；

对于任意的地址，我们都可以根据`arena`的基地址计算该地址所在的页数并通过`spans`数组获得管理该片内存的管理单元`runtime.mspan`，`spans`数组多个连续的位置可能对应一个`runtime.mspan`结构。

####  2.1.1. <a name='-1'></a>线性堆内存的弊端

线性堆内存虽然很简单和方便，但是在C和Go混合使用的时候会导致程序的崩溃：

* 分配的内存地址发生冲突，导致堆的初始化和扩容失败。
* 没有预留的大块内存可能被分配给C语言的二进制，导致扩容后的堆不连续。

###  2.2. <a name='Go1.11'></a>Go1.11版本开始的堆区内存——稀疏内存

稀疏内存是 Go 语言在 1.11 中提出的方案，使用稀疏的内存布局不仅能移除堆大小的上限，还能解决 C 和 Go 混合使用时的地址空间冲突问题。不过因为基于稀疏内存的内存管理失去了内存的连续性这一假设，这也使内存管理变得更加复杂：

<div align=center><img src="/assets/gmm2.png"/></div>

**具体的稀疏内存涉及比较难和底层的东西，目前我的水平只能整理这么多内容，将来有能力了再补充** 。
