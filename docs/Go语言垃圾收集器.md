# Go语言垃圾收集器

<!-- vscode-markdown-toc -->
* 1. [早期的Go垃圾收集策略](#Go)
* 2. [Go语言的内存管理组件](#Go-1)
* 3. [GC的原理](#GC)
	* 3.1. [标记清除](#)
		* 3.1.1. [标记阶段](#-1)
		* 3.1.2. [清除阶段](#-1)
	* 3.2. [三色抽象](#-1)
		* 3.2.1. [三色抽象的工作过程](#-1)
		* 3.2.2. [三色抽象不使用STW会产生的问题](#STW)
	* 3.3. [屏障技术](#-1)

<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->

##  1. <a name='Go'></a>早期的Go垃圾收集策略

早期的Go语言垃圾收集方式是STW(Stop The World)，通过暂停用户程序的方式GC，然而当用户程序越来越多，垃圾越来越多的时候，当系统运行内存达到一定阈值的时候，整个系统就会暂停运行，当GC结束之后，用户程序才可以继续运行。**现在Go语言的GC策略已经复杂了很多** 。

##  2. <a name='Go-1'></a>Go语言的内存管理组件

<div align=center><img src="../assets/gc1.png"/></div>

用户程序Mutator通过内存分配器Allocator在堆上申请内存，而垃圾收集器Collector负责回收Heap上的垃圾。Allocator和Collector共同管理计算机的内存空间。

##  3. <a name='GC'></a>GC的原理

###  3.1. <a name=''></a>标记清除

标记清除([`Mark-Sweep`]())算法是最常见也是最简单的GC算法，标记清除GC器是跟踪式垃圾收集器，其执行过程可以分成**标记([`Mark`]())** 和 **清除([`Sweep`]()**两个过程：

1. 标记阶段——从根对象出发查找并标记堆中的所有存活对象
2. 清除阶段——遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入**空闲链表**

####  3.1.1. <a name='-1'></a>标记阶段

<div align=center><img src="../assets/gc2.png"/></div>

上面从[`Root`]()节点到A, C, D有可达路径，而B, E, F没有，因此B, E, F会被当成垃圾。

####  3.1.2. <a name='-1'></a>清除阶段

<div align=center><img src="../assets/gc3.png"/></div>

GC从根对象出发，**递归遍历** 这些对象，并将所有可达的对象标注为存活状态，，标注结束之后，GC会依次遍历堆中的垃圾对象并清除这些对象，整个过程需要暂停用户程序的执行，也就会出现STW问题，因此我们需要更加复杂的机制去解决STW问题。

###  3.2. <a name='-1'></a>三色抽象

为了解决原始标记清除算法带来的长时间 STW，多数现代的追踪式垃圾收集器都会实现三色标记算法的变种以缩短 STW 的时间。**三色标记算法将程序中的对象分成白色、黑色和灰色三类** 。

* **白色对象** — 潜在的垃圾，其内存可能会被垃圾收集器回收；
* **黑色对象** — 活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象；
* **灰色对象** — 活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；

####  3.2.1. <a name='-1'></a>三色抽象的工作过程

**在垃圾收集器开始工作时，程序中不存在任何的黑色对象，垃圾收集的根对象会被标记成灰色，垃圾收集器只会从灰色对象集合中取出对象开始扫描，当灰色集合中不存在任何对象时，标记阶段就会结束。**

三色标记垃圾收集器的工作原理很简单，我们可以将其归纳成以下几个步骤：

1. 从灰色对象的集合中选择一个灰色对象并将其标记成黑色；
2. 将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收；
3. 重复上述两个步骤直到对象图中不存在灰色对象；

<div align=center><img src="../assets/gc4.png"/></div>

####  3.2.2. <a name='STW'></a>三色抽象不使用STW会产生的问题

因为用户程序可能在标记执行的过程中修改对象的指针，所以三色标记清除算法本身是不可以并发或者增量执行的，它仍然需要 STW，在如下所示的三色标记过程中，**用户程序建立了从 A 对象到 E 对象的引用，但是因为程序中已经不存在灰色对象了，所以 D 对象会被垃圾收集器错误地回收**。

<div align=center><img src="../assets/gc5.png"/></div>

###  3.3. <a name='-1'></a>屏障技术

本来不应该被回收的对象却被回收了，这在内存管理中是非常严重的错误，我们将这种错误称为悬挂指针，即指针没有指向特定类型的合法对象，影响了内存的安全性[5](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#fn:5)，**想要并发或者增量地标记对象还是需要使用屏障技术**。

内存屏障技术是一种屏障指令，它可以让 CPU 或者编译器在执行内存相关操作时遵循特定的约束，目前多数的现代处理器都会乱序执行指令以最大化性能，但是该技术能够保证内存操作的顺序性，在内存屏障前执行的操作一定会先于内存屏障后执行的操作。

**想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性（Tri-color invariant）中的一种** ：

- **强三色不变性** — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；
- **弱三色不变性** — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径

遵循上述两个不变性中的任意一个，我们都能保证垃圾收集算法的正确性，而**屏障技术就是在并发或者增量标记过程中保证三色不变性的重要技术** 。

