# Redis面试题汇总

<!-- vscode-markdown-toc -->
* 1. [Redis是单线程还是多线程?](#Redis)
	* 1.1. [为什么Redis再4.0之前即使使用了单线程，但是仍然那么快？](#Redis4.0)
	* 1.2. [谈谈Redis中的多路复用机制](#Redis-1)
	* 1.3. [Redis线程模型](#Redis-1)
* 2. [Redis存在线程安全的问题吗?](#Redis-1)
* 3. [Redis如何应对缓存穿透？](#Redis-1)
	* 3.1. [Bloom过滤器](#Bloom)
* 4. [Redis如何应对缓存击穿？](#Redis-1)
* 5. [Redis如何应对缓存雪崩?](#Redis-1)
* 6. [Redis如何做缓存预热？](#Redis-1)
* 7. [Redis如何保持缓存一致性?](#Redis-1)
	* 7.1. [Cache Aside](#CacheAside)
	* 7.2. [Read Through](#ReadThrough)
	* 7.3. [Write Through](#WriteThrough)
	* 7.4. [Write Behind Caching](#WriteBehindCaching)
* 8. [Redis如何回收缓存?](#Redis-1)
* 9. [Redis如何淘汰缓存？](#Redis-1)

<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->

##  1. <a name='Redis'></a>Redis是单线程还是多线程?

* 无论什么redis版本，工作线程[`worker thread`]()只有一个
* [`6.x`]()版本出现了IO多线程
* 目前所说的Redis单线程，指的是"其网络IO和键值对读写是由一个线程完成的"，也就是说，**Redis中只有网络请求模块和数据操作模块是单线程的。而其他的如持久化存储模块、集群支撑模块等是多线程的。** Redis 4.0的时候就已经针对部分命令做了多线程化。主要是体现在大数据的异步删除功能上，例如`unlink key`、`flushdb async`、`flushall async`等。

###  1.1. <a name='Redis4.0'></a>为什么Redis再4.0之前即使使用了单线程，但是仍然那么快？

* 单线程，不存在锁竞争的状态，可以在无锁的情况下完成所有的操作，不存在死锁和线程切换带来的时间开销
* Redis大部分的操作都是在内存中完成的，内存的执行效率非常快，并且采用了高效的数据结构，比如`hashtable`和`skiplist`
* Redis采用IO多路复用机制处理大量客户端的`Socket`请求，**注意，多路复用器仅仅负责调度IO事件，不负责真正的读写操作** ，因为这是非阻塞的IO模型，可以让Redis进行高效的网络通信及IO读写

###  1.2. <a name='Redis-1'></a>谈谈Redis中的多路复用机制

**Linux多路复用技术，就是多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互。当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间中。**也就是说，**通过一个线程来处理多个IO流**。

IO多路复用在Linux下包括了三种，select、poll、epoll三种模式。

其实，Redis的IO多路复用程序的所有功能都是通过包装操作系统的IO多路复用函数库来实现的。每个IO多路复用函数库在Redis源码中都有对应的一个单独的文件。

###  1.3. <a name='Redis-1'></a>Redis线程模型

在Redis 中，文件事件处理器([`file event handler`]())包括套接字、I/O 多路复用程序、文件事件分派器、以及事件处理器。使用 I/O 多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。每当一个套接字准备好执行连接应答、写入、读取、关闭等操作时，就会产生一个文件事件。因为一个服务器通常会连接多个套接字，所以多个文件事件有可能会并发地出现。

I/O 多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。尽管多个文件事件可能会并发地出现，但 I/O 多路复用程序总是会将所有产生事件的套接字都入队到一个队列里面，然后通过这个队列，以有序、同步、每次一个套接字的方式向文件事件分派器传送套接字：当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕），I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字。如果一个套接字又可读又可写的话，那么服务器将先读套接字，后写套接字。

总的来说，就是**请求Socker—>IO多路复用程序—>file event dispatcher队列—>file event handler文件事件处理器**

**客户端被读取的顺序不能被保障，但是一个Socket中的操作顺序可以被保障**

##  2. <a name='Redis-1'></a>Redis存在线程安全的问题吗?

Redis虽然可以保障内部串行，但是外部使用Redis的时候需要额外的操作来保障线程安全。**因为Redis不能保障每一个Socket请求被桉顺序读取**

##  3. <a name='Redis-1'></a>Redis如何应对缓存穿透？

- 在接口访问层对用户做校验，如接口传参、登陆状态、n秒内访问接口的次数；
- 利用布隆过滤器，将数据库层有的数据key存储在位数组中，以判断访问的key在底层数据库中是否存在；

###  3.1. <a name='Bloom'></a>Bloom过滤器

- 如果Redis内不存在该数据，则通过布隆过滤器判断数据是否在底层数据库内；
- 如果布隆过滤器告诉我们该key在底层库内不存在，则直接返回null给客户端即可，避免了查询底层数据库的动作；
- 如果布隆过滤器告诉我们该key**极有可能**在底层数据库内存在，那么将查询下推到底层数据库即可；

**Bloom过滤器也无法100%告诉我们该数据是否一定在DB中，只是描述可能性的大小** 。

##  4. <a name='Redis-1'></a>Redis如何应对缓存击穿？

缓存击穿和缓存穿透从名词上可能很难区分开来，它们的区别是：穿透表示底层数据库没有数据且缓存内也没有数据，击穿表示底层数据库有数据而缓存内没有数据。当热点数据key从缓存内失效时，大量访问同时请求这个数据，就会将查询下沉到数据库层，此时数据库层的负载压力会骤增，我们称这种现象为"缓存击穿"。

**解决方法如下:**

- 延长热点key的过期时间或者设置永不过期，如排行榜，首页等一定会有高并发的接口；
- 利用互斥锁保证同一时刻只有一个客户端可以查询底层数据库的这个数据，一旦查到数据就缓存至Redis内，避免其他大量请求同时穿过Redis访问底层数据库；

##  5. <a name='Redis-1'></a>Redis如何应对缓存雪崩?

缓存雪崩是缓存击穿的"大面积"版，缓存击穿是数据库缓存到Redis内的热点数据失效导致大量并发查询穿过redis直接击打到底层数据库，而缓存雪崩是指Redis中大量的key几乎同时过期，然后大量并发查询穿过redis击打到底层数据库上，此时数据库层的负载压力会骤增，我们称这种现象为"缓存雪崩"。事实上缓存雪崩相比于缓存击穿更容易发生，对于大多数公司来讲，同时超大并发量访问同一个过时key的场景的确太少见了，而大量key同时过期，大量用户访问这些key的几率相比缓存击穿来说明显更大。

**解决方法如下:**

- 在可接受的时间范围内随机设置key的过期时间，分散key的过期时间，以防止大量的key在同一时刻过期；
- 对于一定要在固定时间让key失效的场景(例如每日12点准时更新所有最新排名)，可以在固定的失效时间时在接口服务端设置随机延时，将请求的时间打散，让一部分查询先将数据缓存起来；
- 延长热点key的过期时间或者设置永不过期，这一点和缓存击穿中的方案一样；

##  6. <a name='Redis-1'></a>Redis如何做缓存预热？

缓存预热如字面意思，当系统上线时，缓存内还没有数据，如果直接提供给用户使用，每个请求都会穿过缓存去访问底层数据库，如果并发大的话，很有可能在上线当天就会宕机，因此我们需要在上线前先将数据库内的热点数据缓存至Redis内再提供出去使用，这种操作就成为"缓存预热"。

缓存预热的实现方式有很多，**比较通用的方式是写个批任务，在启动项目时或定时去触发将底层数据库内的热点数据加载到缓存内。**

##  7. <a name='Redis-1'></a>Redis如何保持缓存一致性?

缓存服务（Redis）和数据服务（底层数据库）是相互独立且异构的系统，在更新缓存或更新数据的时候无法做到原子性的同时更新两边的数据，因此在并发读写或第二步操作异常时会遇到各种数据不一致的问题。如何解决并发场景下更新操作的双写一致是缓存系统的一个重要知识点。

###  7.1. <a name='CacheAside'></a>Cache Aside

查询：先查缓存，缓存没有就查数据库，然后加载至缓存内；更新：先更新数据库，然后让缓存失效；或者先失效缓存然后更新数据库； 

###  7.2. <a name='ReadThrough'></a>Read Through

在查询操作中更新缓存，即当缓存失效时，Cache Aside 模式是由调用方负责把数据加载入缓存，而 Read Through 则用缓存服务自己来加载；

###  7.3. <a name='WriteThrough'></a>Write Through

在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后由**缓存自己更新数据库**； 

###  7.4. <a name='WriteBehindCaching'></a>Write Behind Caching

俗称write back，在更新数据的时候，只更新缓存，不更新数据库，**缓存会异步地定时批量更新数据库**；

##  8. <a name='Redis-1'></a>Redis如何回收缓存?

* 后台轮询，分段分批删除过期的key(速度慢，消耗大)
* 请求的时候判断缓存过期，如果过期，就回收(速度块，速度高)

##  9. <a name='Redis-1'></a>Redis如何淘汰缓存？

Redis在发生内存空间不足的情况下会强制回收掉部分缓存。有如下淘汰机制：

* `LRU/LFU/Random/TTL`
* 全空间淘汰，全部缓存都淘汰(慎用)
* 设置过过期的缓存集合淘汰
